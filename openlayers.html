<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>OpenLayers demo for ets2-mobile-route-advisor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<!-- Note: if this demo gets incorporated into ets2-mobile-route-advisor, I'd recommend including a copy of these files. That way, it will work even without Internet connection. -->
<!--link rel="stylesheet" href="http://openlayers.org/en/v3.8.2/css/ol.css" type="text/css"-->
<!--script src="http://openlayers.org/en/v3.8.2/build/ol.js" type="text/javascript"></script-->
<!--script src="http://openlayers.org/en/v3.8.2/build/ol-debug.js" type="text/javascript"></script-->
<link rel="stylesheet" href="ol-3.9.0.css" type="text/css">
<script src="ol-3.9.0.js" type="text/javascript"></script>

<style>
body {
	font-size: 9vmin;
}

#map {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
}

#track_checkbox_label {
	position: absolute;
	bottom: 0.5em;
	left: 0.5em;
	background: white;
	color: black;
	padding: 2px;
	border-radius: 4px;
	font-size: 12px;
}

/* Overriding some styles from OpenLayers built-in CSS. */
#map .ol-control {
	background: transparent;
	padding: 0;
	border-radius: 0;
}
#map .ol-control button {
	color: #cecece;
	background: #6c6c6c;
	background: linear-gradient(to bottom, #3c3c3c 0%, #6c6c6c 45%, #3c3c3c 100%);
	box-sizing: content-box;
	overflow: hidden;
	width: 1em;
	height: 1em;
	font-size: 1em;
	line-height: 1.0;
	text-shadow: #000 0 0 0.1em;
	border-radius: 0.1em;
	padding: 0.1em;
	border: 0;
	margin: 0;
}
#map .ol-control button:active {
	color: #242424;
	background: #ffcc2f;
	background: linear-gradient(to bottom, #ab7d00 0%, #ffcc2f 45%, #ab7d00 100%);
	text-shadow: none;
}
#map .ol-compass {
	font-size: inherit;
}
#map .ol-zoom {
	top: auto;
	left: auto;
	right: 0.5em;
	bottom: 0.5em;
	display: flex;
	flex-direction: row-reverse;
}
#map .ol-zoom > button {
	flex-grow: 0;
	flex-shrink: 0;
	margin-left: 0.2em;
}

</style>
</head>
<body>
<div id="map"></div>

<label id="track_checkbox_label"><input type="checkbox" id="track_checkbox"> Track a random virtual position/rotation</label>

<script>
// Based on http://forum.scssoft.com/viewtopic.php?f=41&t=186779
function calculatePixelCoordinate(x, y, pointsPerPixel, x0, y0) {
	return [
		(x / pointsPerPixel + x0) | 0,
		(y / pointsPerPixel + y0) | 0
	];
}
function calculatePixelCoordinateEu(x, y) {
	return calculatePixelCoordinate(x, y, 7.278, 11367, 9962);
}
function calculatePixelCoordinateUk(x, y) {
	return calculatePixelCoordinate(x, y, 9.69522, 10226, 9826);
}

function game_coord_to_pixels(x, y) {
	// http://forum.scssoft.com/viewtopic.php?p=402836#p402836
	var r = null;
	if (x < -31812 && y < -5618) {
		r = calculatePixelCoordinateUk(x, y);
	} else {
		r = calculatePixelCoordinateEu(x, y);
	}

	// Inverting Y axis, because of OpenLayers coordinates.
	r[1] = MAX_Y - r[1];
	return r;
}


var MAX_X = 19200;
var MAX_Y = 18688;

var TILE_MAX_X = Math.ceil(MAX_X / Math.pow(2,7) / 256) * Math.pow(2,7) * 256;
var TILE_MAX_Y = Math.ceil(MAX_Y / Math.pow(2,7) / 256) * Math.pow(2,7) * 256;


var projection = new ol.proj.Projection({
	// Any name here. I chose "Funbit" because we are using funbit's image coordinates.
	code: 'Funbit',
	units: 'pixels',
	extent: [0, 0, MAX_X, MAX_Y],
	worldExtent: [0, 0, MAX_X, MAX_Y]
});
ol.proj.addProjection(projection);

ol.proj.addCoordinateTransforms('EPSG:4326', projection,
	function(coord) {
	  return [coord[0], -coord[1]];
	},
	function(coord) {
	  return [coord[0], -coord[1]];
	}
);
ol.proj.addCoordinateTransforms('EPSG:3857', projection,
	function(coord) {
	  return [coord[0], -coord[1]];
	},
	function(coord) {
	  return [coord[0], -coord[1]];
	}
);

var markers = [
	new ol.Feature({
		geometry: new ol.geom.Point([0, 0]),
		name: 'Origin',
	}),
	new ol.Feature({
		geometry: new ol.geom.Point([256, 256]),
		name: 'First Tile',
	}),
	new ol.Feature({
		geometry: new ol.geom.Point([256, MAX_Y - 256]),
		name: 'Other First Tile',
	}),
	new ol.Feature({
		geometry: new ol.geom.Point([MAX_X, MAX_Y]),
		name: 'End',
	}),
	new ol.Feature({
		geometry: new ol.geom.Point(game_coord_to_pixels(41744.53, 17305.5156)),
		name: 'Debrecen',
	}),
	new ol.Feature({
		geometry: new ol.geom.Point(game_coord_to_pixels(-49770.64, -48417.68)),
		name: 'Glasgow',
	}),
];

var feature_source = new ol.source.Vector({
	features: markers,
	wrapX: false
});

var custom_tilegrid = new ol.tilegrid.TileGrid({
	extent: [0, 0, MAX_X, MAX_Y],
	minZoom: 0,
	origin: [0, MAX_Y],
	tileSize: [256, 256],
	resolutions: (function(){
		var r = [];
		for (var z = 0; z <= 7; ++z) {
			r[z] = Math.pow(2, 7 - z);
		}
		return r;
	})()
});

var map = new ol.Map({
	target: 'map',
	controls: [
		// new ol.control.ZoomSlider(),
		// new ol.control.OverviewMap(),
		// new ol.control.MousePosition(),  // DEBUG
		new ol.control.Zoom(),
		new ol.control.Rotate({
			autoHide: false,
			label: '\u2B06'
		})
	],
	interactions: ol.interaction.defaults().extend([
		// Rotating by using two fingers is implemented in PinchRotate(), which is enabled by default.
		// With DragRotateAndZoom(), it is possible to use Shift+mouse-drag to rotate the map.
		// Without it, Shift+mouse-drag creates a rectangle to zoom to an area.
		new ol.interaction.DragRotateAndZoom()
	]),
	layers: [
		new ol.layer.Tile({
			extent: [0, 0, MAX_X, MAX_Y],
			source: new ol.source.XYZ({
				projection: projection,
				url: 'funbit-map-medium-dark-final/{z}/{y}/{x}.png',
				tileSize: [256, 256],
				// Using createXYZ() makes the vector layer (with the features) unaligned.
				// It also tries loading non-existent tiles.
				//
				// Using custom_tilegrid causes rescaling of all image tiles before drawing
				// (i.e. no image will be rendered at 1:1 pixels), But fixes all other issues.
				tileGrid: custom_tilegrid,
				// tileGrid: ol.tilegrid.createXYZ({
				// 	extent: [0, 0, MAX_X, MAX_Y],
				// 	minZoom: 0,
				// 	maxZoom: 7,
				// 	tileSize: [256, 256]
				// }),
				wrapX: false,
				maxZoom: 7
			})
		}),
		// Debug layer below.
		// new ol.layer.Tile({
		// 	extent: [0, 0, MAX_X, MAX_Y],
		// 	source: new ol.source.TileDebug({
		// 		projection: projection,
		// 		tileGrid: custom_tilegrid,
		// 		// tileGrid: ol.tilegrid.createXYZ({
		// 		// 	extent: [0, 0, MAX_X, MAX_Y],
		// 		// 	minZoom: 0,
		// 		// 	maxZoom: 7,
		// 		// 	tileSize: [256, 256]
		// 		// }),
		// 		wrapX: false
		// 	})
		// }),
		new ol.layer.Vector({
			source: feature_source
			//style: ...
		})
	],
	view: new ol.View({
		projection: projection,
		extent: [0, 0, MAX_X, MAX_Y],
		//center: ol.proj.transform([37.41, 8.82], 'EPSG:4326', 'EPSG:3857'),
		center: [MAX_X/2, MAX_Y/2],
		minZoom: 0,
		maxZoom: 9,
		zoom: 2
	})
});


// map.on('singleclick', function(ev) {
//   var coordinate = ev.coordinate;
//   console.log(coordinate);
// });

// map.getView().on('change:center', function(ev) {
//   console.log(ev);
// });
// map.getView().on('change:rotation', function(ev) {
//   console.log(ev);
// });




// https://stackoverflow.com/q/32868671/
var auto_tracking = false;
document.getElementById('track_checkbox').checked = auto_tracking;
var ignore_change_events = false;
map.getView().on(['change:center', 'change:rotation'], function(ev) {
	if (ignore_change_events) {
		return;
	}
	auto_tracking = false;
	document.getElementById('track_checkbox').checked = auto_tracking;
});

var trackingCheckboxControl = new ol.control.Control({
	element: document.getElementById('track_checkbox_label')
});
map.addControl(trackingCheckboxControl);
document.getElementById('track_checkbox').addEventListener('click', function(ev) {
	auto_tracking = ev.target.checked;
});


// Virtual, fake, mock, dummy truck position and rotation.
// Just some random numbers that get updated all the time.
var truck_pos = [MAX_X/2, MAX_Y/2];
var truck_rot = 0;
var truck_delta_pos = [0, 0];
var truck_delta_rot = 0;
setInterval(function() {
	if (!auto_tracking) {
		return;
	}

	truck_delta_pos[0] += (Math.random() - 0.5) * 1;
	truck_delta_pos[1] += (Math.random() - 0.5) * 1;
	truck_delta_rot += (Math.random() - 0.5) * (Math.PI / 256);

	truck_pos[0] += truck_delta_pos[0];
	truck_pos[1] += truck_delta_pos[1];
	truck_rot += truck_delta_rot;

	ignore_change_events = true;
	map.getView().setCenter(truck_pos);
	map.getView().setRotation(truck_rot);
	ignore_change_events = false;
}, 40);

</script>

</body>
</html>
